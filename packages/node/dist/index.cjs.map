{"version":3,"sources":["../src/index.ts","../src/constants/index.ts"],"sourcesContent":["// packages/node/src/index.ts\nimport {QUANTUMAUTH_SERVER_URL, QUANTUMAUTH_VERIFICATION_PATH} from \"./constants\";\n\nexport * from \"./constants\";\n\nexport interface QuantumAuthNodeConfig {\n    backendApiKey?: string;\n    timeoutMs?: number;\n}\n\nexport interface VerificationRequestPayload {\n    method: string;\n    path: string;\n    headers: Record<string, string>;\n}\n\nexport interface VerificationResponse {\n    authenticated: boolean;\n    userId?: string;\n    payload?: unknown; // decrypted payload\n    error?: string;\n}\n\nexport interface QuantumAuthContext {\n    userId: string;\n    payload: unknown;\n}\n\nexport async function verifyRequestWithServer(\n    cfg: QuantumAuthNodeConfig,\n    input: VerificationRequestPayload\n): Promise<VerificationResponse> {\n    const url = joinUrl(QUANTUMAUTH_SERVER_URL, QUANTUMAUTH_VERIFICATION_PATH);\n\n    const controller = new AbortController();\n    const timeout = setTimeout(\n        () => controller.abort(),\n        cfg.timeoutMs ?? 3000\n    );\n\n    try {\n        const headers: Record<string, string> = {\n            \"Content-Type\": \"application/json\",\n        };\n        // for future use\n        if (cfg.backendApiKey) {\n            headers[\"X-QuantumAuth-Backend-Key\"] = cfg.backendApiKey;\n        }\n\n        const res = await fetch(url, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(input),\n            signal: controller.signal,\n        });\n\n        const text = await res.text();\n        let json: any = null;\n        try {\n            json = text ? JSON.parse(text) : null;\n        } catch {\n            json = null;\n        }\n\n        if (!res.ok) {\n            return {\n                authenticated: false,\n                error:\n                    json?.error ??\n                    `QA server verify failed: HTTP ${res.status} ${res.statusText}`,\n            };\n        }\n\n        return {\n            authenticated: !!json?.authenticated,\n            userId: json?.user_id ?? json?.userId,\n            // payload: json?.payload ?? json?.data, // for future encryption\n        };\n    } catch (err: any) {\n        return {\n            authenticated: false,\n            error: String(err?.message ?? err),\n        };\n    } finally {\n        clearTimeout(timeout);\n    }\n}\n\nexport function createExpressQuantumAuthMiddleware(\n    cfg: QuantumAuthNodeConfig\n) {\n    return async function quantumAuthMiddleware(\n        req: any,\n        res: any,\n        next: () => void\n    ) {\n        try {\n\n            const encrypted = req.body;\n\n            if (!encrypted) {\n                res.status(400).json({ error: \"Missing request body for QuantumAuth\" });\n                return;\n            }\n\n            const method: string = req.method;\n            const path: string = req.originalUrl || req.url || \"\";\n\n            // Extract only QuantumAuth-related headers to send to QA server\n            const incomingHeaders: Record<string, string> = {};\n            const rawHeaders = req.headers || {};\n\n            for (const [key, value] of Object.entries(rawHeaders)) {\n                if (!value) continue;\n\n                const lower = key.toLowerCase();\n                if (\n                    lower === \"authorization\" ||\n                    lower.startsWith(\"x-quantumauth-\") ||\n                    lower === \"x-qa-signature\"\n                ) {\n                    incomingHeaders[key] = Array.isArray(value)\n                        ? value.join(\",\")\n                        : String(value);\n                }\n            }\n\n            const verifyPayload: VerificationRequestPayload = {\n                method,\n                path,\n                headers: incomingHeaders,\n            };\n\n            const result = await verifyRequestWithServer(cfg, verifyPayload);\n\n            req.userId = result.authenticated ? result.userId : null;\n\n            if (!result.authenticated || !result.userId) {\n                res.status(401).json({\n                    error: result.error ?? \"QuantumAuth authentication failed\",\n                });\n                return;\n            }\n\n            // Attach context + decrypted payload to req\n            const ctx: QuantumAuthContext = {\n                userId: result.userId,\n                payload: result.payload,\n            };\n\n            (req as any).quantumAuth = ctx;\n            (req as any).qa = ctx; // short alias\n            if (result.payload !== undefined) {\n                req.body = result.payload;\n            }\n\n            return next();\n        } catch (err: any) {\n            res\n                .status(500)\n                .json({ error: `QuantumAuth middleware error: ${String(err)}` });\n        }\n    };\n}\n\n\nfunction joinUrl(base: string, path: string): string {\n    if (!base.endsWith(\"/\") && !path.startsWith(\"/\")) {\n        return base + \"/\" + path;\n    }\n    if (base.endsWith(\"/\") && path.startsWith(\"/\")) {\n        return base + path.slice(1);\n    }\n    return base + path;\n}\n","export const QUANTUMAUTH_ALLOWED_HEADERS = [\n    \"Content-Type\",\n    \"Authorization\",\n    \"X-QuantumAuth-Canonical-B64\"\n] as const;\n\nexport const QUANTUMAUTH_VERIFICATION_PATH: string = \"/quantum-auth/v1/auth/verify\";\nexport const QUANTUMAUTH_SERVER_URL: string = \"http://localhost:1042\";"],"mappings":"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","names":[]}