{"version":3,"sources":["../src/index.ts"],"sourcesContent":["// packages/node/src/index.ts\n\n/**\n * QuantumAuth Node / backend SDK\n *\n * Goal: make it trivial for a developer to protect an endpoint:\n *\n *   app.post(\"/api/secure\", qaMiddleware, (req, res) => {\n *     // req.quantumAuth.userId, req.quantumAuth.deviceId, req.body = decrypted payload\n *   });\n */\n\nexport interface QuantumAuthNodeConfig {\n    /** Base URL of the QuantumAuth server, e.g. \"http://localhost:1042\" */\n    qaServerUrl: string;\n\n    /**\n     * Path of the verification endpoint on the QuantumAuth server.\n     * You said you already have “an endpoint to verify request” – plug it here.\n     * Example: \"/quantum-auth/verify-request\"\n     */\n    verifyPath?: string;\n\n    /**\n     * Optional shared secret/API key between your backend and the QA server.\n     * If used, the QA server can require this in an \"X-QuantumAuth-Backend-Key\" header.\n     */\n    backendApiKey?: string;\n\n    /** Timeout for the call to the QA server (ms). Default: 3000 */\n    timeoutMs?: number;\n}\n\n/**\n * What we send from backend → QuantumAuth server to verify/decrypt.\n * This must match what the QA server expects.\n */\nexport interface VerificationRequestPayload {\n    method: string;\n    path: string;\n    headers: Record<string, string>;\n    encrypted: unknown; // the EncryptedPayload JSON received from the frontend\n}\n\n/**\n * What we expect back from the QuantumAuth server.\n * Adapt these fields to match your real endpoint’s response.\n */\nexport interface VerificationResponse {\n    authenticated: boolean;\n    userId?: string;\n    deviceId?: string;\n    payload?: unknown; // decrypted payload\n    error?: string;\n}\n\n/**\n * Context attached to the Express request object on success.\n */\nexport interface QuantumAuthContext {\n    userId: string;\n    payload: unknown;\n}\n\n/**\n * Low-level helper: verify a single request with the QuantumAuth server.\n * You can reuse this even outside Express (Fastify, etc.).\n */\nexport async function verifyRequestWithServer(\n    cfg: QuantumAuthNodeConfig,\n    input: VerificationRequestPayload\n): Promise<VerificationResponse> {\n    const verifyPath = cfg.verifyPath ?? \"/quantum-auth/verify-request\";\n    const url = joinUrl(cfg.qaServerUrl, verifyPath);\n\n    const controller = new AbortController();\n    const timeout = setTimeout(\n        () => controller.abort(),\n        cfg.timeoutMs ?? 3000\n    );\n\n    try {\n        const headers: Record<string, string> = {\n            \"Content-Type\": \"application/json\",\n        };\n        if (cfg.backendApiKey) {\n            headers[\"X-QuantumAuth-Backend-Key\"] = cfg.backendApiKey;\n        }\n\n        const res = await fetch(url, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(input),\n            signal: controller.signal,\n        });\n\n        const text = await res.text();\n        let json: any = null;\n        try {\n            json = text ? JSON.parse(text) : null;\n        } catch {\n            json = null;\n        }\n\n        if (!res.ok) {\n            return {\n                authenticated: false,\n                error:\n                    json?.error ??\n                    `QA server verify failed: HTTP ${res.status} ${res.statusText}`,\n            };\n        }\n\n        return {\n            authenticated: !!json?.authenticated,\n            userId: json?.user_id ?? json?.userId,\n            deviceId: json?.device_id ?? json?.deviceId,\n            payload: json?.payload ?? json?.data,\n            error: json?.error,\n        };\n    } catch (err: any) {\n        return {\n            authenticated: false,\n            error: String(err?.message ?? err),\n        };\n    } finally {\n        clearTimeout(timeout);\n    }\n}\n\n/**\n * Express-compatible middleware factory.\n *\n * Usage:\n *\n *   import express from \"express\";\n *   import { createExpressQuantumAuthMiddleware } from \"@quantumauth/node\";\n *\n *   const app = express();\n *   app.use(express.json()); // IMPORTANT: parse JSON body first\n *\n *   app.post(\n *     \"/api/secure\",\n *     createExpressQuantumAuthMiddleware({\n *       qaServerUrl: \"http://localhost:1042\",\n *       verifyPath: \"/quantum-auth/verify-request\",\n *       backendApiKey: process.env.QA_BACKEND_KEY,\n *     }),\n *     (req, res) => {\n *       const qa = (req as any).quantumAuth as QuantumAuthContext;\n *       // qa.userId, qa.deviceId, qa.payload (== req.body)\n *       res.json({ ok: true, user: qa.userId, data: qa.payload });\n *     }\n *   );\n */\nexport function createExpressQuantumAuthMiddleware(\n    cfg: QuantumAuthNodeConfig\n) {\n    return async function quantumAuthMiddleware(\n        req: any,\n        res: any,\n        next: () => void\n    ) {\n        try {\n            // Expect body to be the encrypted JSON coming from @quantumauth/web.\n            const encrypted = req.body;\n\n            if (!encrypted) {\n                res.status(400).json({ error: \"Missing request body for QuantumAuth\" });\n                return;\n            }\n\n            const method: string = req.method;\n            const path: string = req.originalUrl || req.url || \"\";\n\n            // Extract only QuantumAuth-related headers to send to QA server\n            const incomingHeaders: Record<string, string> = {};\n            const rawHeaders = req.headers || {};\n\n            for (const [key, value] of Object.entries(rawHeaders)) {\n                if (!value) continue;\n\n                const lower = key.toLowerCase();\n                if (\n                    lower === \"authorization\" ||\n                    lower.startsWith(\"x-quantumauth-\") ||\n                    lower === \"x-qa-signature\"\n                ) {\n                    incomingHeaders[key] = Array.isArray(value)\n                        ? value.join(\",\")\n                        : String(value);\n                }\n            }\n\n            const verifyPayload: VerificationRequestPayload = {\n                method,\n                path,\n                headers: incomingHeaders,\n                encrypted,\n            };\n\n            const result = await verifyRequestWithServer(cfg, verifyPayload);\n\n            console.log(\"result\", result)\n\n            if (!result.authenticated || !result.userId) {\n                res.status(401).json({\n                    error: result.error ?? \"QuantumAuth authentication failed\",\n                });\n                return;\n            }\n\n            // Attach context + decrypted payload to req\n            const ctx: QuantumAuthContext = {\n                userId: result.userId,\n                payload: result.payload,\n            };\n\n            (req as any).quantumAuth = ctx;\n            (req as any).qa = ctx; // short alias\n            if (result.payload !== undefined) {\n                req.body = result.payload;\n            }\n\n            return next();\n        } catch (err: any) {\n            res\n                .status(500)\n                .json({ error: `QuantumAuth middleware error: ${String(err)}` });\n        }\n    };\n}\n\n// ---------- helpers ----------\n\nfunction joinUrl(base: string, path: string): string {\n    if (!base.endsWith(\"/\") && !path.startsWith(\"/\")) {\n        return base + \"/\" + path;\n    }\n    if (base.endsWith(\"/\") && path.startsWith(\"/\")) {\n        return base + path.slice(1);\n    }\n    return base + path;\n}\n"],"mappings":"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","names":[]}