{"version":3,"sources":["../src/index.ts","../src/extensionBridge.ts"],"sourcesContent":["// packages/web/src/index.ts\nimport {isQuantumAuthExtensionAvailable, qaRequest} from \"./extensionBridge\";\n\nexport interface QuantumAuthWebConfig {\n    backendBaseUrl: string;\n    appId?: string;\n}\n\nexport interface ProtectedCallOptions<TBody = unknown> {\n    method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n    path: string;\n    body?: TBody;\n}\n\nexport interface ProtectedCallResult<T = unknown> {\n    ok: boolean;\n    status: number;\n    headers: Headers;\n    data: T | null;\n    raw: Response;\n}\n\ninterface ChallengeResponse {\n    qaProof: Record<string, string>;\n}\n\nexport class QuantumAuthWebClient {\n    private readonly backendBaseUrl: string;\n    private readonly appId?: string;\n\n    constructor(cfg: QuantumAuthWebConfig) {\n        this.backendBaseUrl = cfg.backendBaseUrl.replace(/\\/+$/, \"\");\n        this.appId = cfg.appId;\n    }\n\n    async request<TResp = unknown, TBody = unknown>(\n        opts: ProtectedCallOptions<TBody>,\n    ): Promise<ProtectedCallResult<TResp>> {\n        const challenge = await this.requestChallenge({\n            method: opts.method,\n            path: opts.path,\n            backendHost: this.extractHost(this.backendBaseUrl),\n        });\n\n        const url = this.backendBaseUrl + opts.path;\n\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n        });\n\n        for (const [k, v] of Object.entries(challenge.qaProof)) {\n            headers.set(k, v);\n        }\n\n        const resp = await fetch(url, {\n            method: opts.method,\n            headers,\n            body: opts.method === \"GET\" ? undefined : JSON.stringify(opts.body ?? {}),\n            credentials: \"include\",\n        });\n\n        let data: TResp | null = null;\n        try {\n            const text = await resp.text();\n            data = text ? (JSON.parse(text) as TResp) : null;\n        } catch {\n            data = null;\n        }\n\n        return {\n            ok: resp.ok,\n            status: resp.status,\n            headers: resp.headers,\n            data,\n            raw: resp,\n        };\n    }\n\n    private async requestChallenge(params: {\n        method: string;\n        path: string;\n        backendHost: string;\n    }): Promise<ChallengeResponse> {\n        if (typeof window === \"undefined\") {\n            throw new Error(\n                \"QuantumAuthWebClient.requestChallenge must run in a browser\",\n            );\n        }\n// todo move this outside of the request.\n        const hasExtension = await isQuantumAuthExtensionAvailable();\n        if (!hasExtension) {\n            throw new Error(\n                \"QuantumAuth browser extension not detected. Please install the QuantumAuth extension to use protected requests.\",\n            );\n        }\n\n        const resp = await qaRequest<{\n            qaProof?: Record<string, string>;\n            data?: { qaProof?: Record<string, string> };\n        }>({\n            action: \"request_challenge\",\n            data: {\n                method: params.method,\n                path: params.path,\n                backendHost: params.backendHost,\n                appId: this.appId,\n            },\n        });\nconsole.log(\"QuantumAuth challenge response:\", resp);\n        const qaProof =\n            resp.qaProof ??\n            resp.data?.qaProof ??\n            {};\n\n        console.log(\"QuantumAuth challenge response:\", qaProof);\n\n        return {\n            qaProof,\n        };\n    }\n\n    private extractHost(url: string): string {\n        try {\n            const u = new URL(url);\n            return u.host;\n        } catch {\n            return url.replace(/^https?:\\/\\//, \"\").split(\"/\")[0];\n        }\n    }\n}\n","// Tiny helper used by web apps to talk to the QuantumAuth browser extension.\n\nexport interface QuantumAuthExtensionPayload<T = unknown> {\n    action: string;\n    data?: T;\n}\n\nlet cachedExtensionAvailable: boolean | null = null;\n\n\nexport function qaRequest<TResp = unknown, TData = unknown>(\n    payload: QuantumAuthExtensionPayload<TData>,\n    timeoutMs = 15000\n): Promise<TResp> {\n    if (typeof window === \"undefined\") {\n        return Promise.reject(new Error(\"qaRequest must be called in a browser context\"));\n    }\n\n    return new Promise<TResp>((resolve, reject) => {\n        const correlationId =\n            (window.crypto as Crypto | undefined)?.randomUUID?.() ??\n            `qa-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\n        const timer = setTimeout(() => {\n            window.removeEventListener(\"message\", onMessage);\n            reject(new Error(\"QuantumAuth extension timeout\"));\n        }, timeoutMs);\n\n        function onMessage(event: MessageEvent) {\n            const msg = event.data;\n\n            if (!msg || msg.type !== \"QUANTUMAUTH_RESPONSE\" || msg.correlationId !== correlationId) {\n                return;\n            }\n\n            clearTimeout(timer);\n            window.removeEventListener(\"message\", onMessage);\n\n            const p = msg.payload as any;\n\n            const deepError = p?.error ?? p?.data?.error ?? p?.data?.message;\n\n            const isOk =\n                msg.error == null &&\n                p?.ok !== false &&\n                p?.data?.ok !== false;\n\n            if (!isOk) {\n                reject(new Error(msg.error || deepError || \"QuantumAuth extension error\"));\n                return;\n            }\n\n            resolve(p?.data as TResp);\n        }\n\n        window.addEventListener(\"message\", onMessage);\n\n        window.postMessage(\n            { type: \"QUANTUMAUTH_REQUEST\", correlationId, payload },\n            \"*\",\n        );\n    });\n}\n\n\n// Public helper: detect whether the QuantumAuth extension is available.\n// Uses a small \"ping\" request and caches the result.\nexport async function isQuantumAuthExtensionAvailable(timeoutMs = 1000): Promise<boolean> {\n    if (typeof window === \"undefined\") return false;\n\n    // only short-circuit on true\n    if (cachedExtensionAvailable === true) return true;\n\n    try {\n        await qaRequest({ action: \"ping\" }, timeoutMs);\n        cachedExtensionAvailable = true;\n        return true;\n    } catch {\n        // do NOT cache false\n        return false;\n    }\n}\n"],"mappings":"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","names":[]}