{"version":3,"sources":["../src/index.ts","../src/extensionBridge.ts"],"sourcesContent":["// packages/web/src/index.ts\nimport {isQuantumAuthExtensionAvailable, qaRequest} from \"./extensionBridge\";\n\nexport interface QuantumAuthWebConfig {\n    backendBaseUrl: string;\n    appId?: string;\n}\n\nexport interface ProtectedCallOptions<TBody = unknown> {\n    method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n    path: string;\n    body?: TBody;\n}\n\nexport interface ProtectedCallResult<T = unknown> {\n    ok: boolean;\n    status: number;\n    headers: Headers;\n    data: T | null;\n    raw: Response;\n}\n\ninterface ChallengeResponse {\n    qaProof: Record<string, string>;\n}\n\nexport class QuantumAuthWebClient {\n    private readonly backendBaseUrl: string;\n    private readonly appId?: string;\n\n    constructor(cfg: QuantumAuthWebConfig) {\n        this.backendBaseUrl = cfg.backendBaseUrl.replace(/\\/+$/, \"\");\n        this.appId = cfg.appId;\n    }\n\n    async request<TResp = unknown, TBody = unknown>(\n        opts: ProtectedCallOptions<TBody>,\n    ): Promise<ProtectedCallResult<TResp>> {\n        const challenge = await this.requestChallenge({\n            method: opts.method,\n            path: opts.path,\n            backendHost: this.extractHost(this.backendBaseUrl),\n        });\n\n        const url = this.backendBaseUrl + opts.path;\n\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n        });\n\n        for (const [k, v] of Object.entries(challenge.qaProof)) {\n            headers.set(k, v);\n        }\n\n        const resp = await fetch(url, {\n            method: opts.method,\n            headers,\n            body: opts.method === \"GET\" ? undefined : JSON.stringify(opts.body ?? {}),\n            credentials: \"include\",\n        });\n\n        let data: TResp | null = null;\n        try {\n            const text = await resp.text();\n            data = text ? (JSON.parse(text) as TResp) : null;\n        } catch {\n            data = null;\n        }\n\n        return {\n            ok: resp.ok,\n            status: resp.status,\n            headers: resp.headers,\n            data,\n            raw: resp,\n        };\n    }\n\n    private async requestChallenge(params: {\n        method: string;\n        path: string;\n        backendHost: string;\n    }): Promise<ChallengeResponse> {\n        if (typeof window === \"undefined\") {\n            throw new Error(\n                \"QuantumAuthWebClient.requestChallenge must run in a browser\",\n            );\n        }\n\n        const hasExtension = await isQuantumAuthExtensionAvailable();\n        if (!hasExtension) {\n            throw new Error(\n                \"QuantumAuth browser extension not detected. Please install the QuantumAuth extension to use protected requests.\",\n            );\n        }\n\n        const resp = await qaRequest<{\n            qaProof?: Record<string, string>;\n            data?: { qaProof?: Record<string, string> };\n        }>({\n            action: \"request_challenge\",\n            data: {\n                method: params.method,\n                path: params.path,\n                backendHost: params.backendHost,\n                appId: this.appId,\n            },\n        });\n\n        const qaProof =\n            resp.qaProof ??\n            resp.data?.qaProof ??\n            {};\n\n        return {\n            qaProof,\n        };\n    }\n\n    private extractHost(url: string): string {\n        try {\n            const u = new URL(url);\n            return u.host;\n        } catch {\n            return url.replace(/^https?:\\/\\//, \"\").split(\"/\")[0];\n        }\n    }\n}\n","// Tiny helper used by web apps to talk to the QuantumAuth browser extension.\n\nexport interface QuantumAuthExtensionPayload<T = unknown> {\n    action: string;\n    data?: T;\n}\n\nlet cachedExtensionAvailable: boolean | null = null;\n\n\nexport function qaRequest<TResp = unknown, TData = unknown>(\n    payload: QuantumAuthExtensionPayload<TData>,\n    timeoutMs = 15000\n): Promise<TResp> {\n    if (typeof window === \"undefined\") {\n        return Promise.reject(\n            new Error(\"qaRequest must be called in a browser context\"),\n        );\n    }\n\n    return new Promise<TResp>((resolve, reject) => {\n        // Fallback if crypto.randomUUID is not available\n        const correlationId =\n            (window.crypto as Crypto | undefined)?.randomUUID?.() ??\n            `qa-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n\n        const timer = setTimeout(() => {\n            window.removeEventListener(\"message\", onMessage);\n            reject(new Error(\"QuantumAuth extension timeout\"));\n        }, timeoutMs);\n\n        function onMessage(event: MessageEvent) {\n            const msg = event.data;\n            if (\n                !msg ||\n                msg.type !== \"QUANTUMAUTH_RESPONSE\" ||\n                msg.correlationId !== correlationId\n            ) {\n                return;\n            }\n\n            clearTimeout(timer);\n            window.removeEventListener(\"message\", onMessage);\n\n            if (msg.error || msg.payload?.ok === false) {\n                reject(\n                    new Error(\n                        msg.error || msg.payload?.error || \"QuantumAuth extension error\",\n                    ),\n                );\n            } else {\n                resolve(msg.payload?.data as TResp);\n            }\n        }\n\n        window.addEventListener(\"message\", onMessage);\n\n        window.postMessage(\n            {\n                type: \"QUANTUMAUTH_REQUEST\",\n                correlationId,\n                payload,\n            },\n            \"*\",\n        );\n    });\n}\n\n// Public helper: detect whether the QuantumAuth extension is available.\n// Uses a small \"ping\" request and caches the result.\nexport async function isQuantumAuthExtensionAvailable(\n    timeoutMs = 1000,\n): Promise<boolean> {\n    if (typeof window === \"undefined\") {\n        return false;\n    }\n\n    if (cachedExtensionAvailable !== null) {\n        return cachedExtensionAvailable;\n    }\n\n    try {\n        await qaRequest<{ message?: string }, void>(\n            { action: \"ping\" },\n            timeoutMs,\n        );\n        cachedExtensionAvailable = true;\n    } catch {\n        cachedExtensionAvailable = false;\n    }\n\n    return cachedExtensionAvailable;\n}"],"mappings":"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","names":[]}