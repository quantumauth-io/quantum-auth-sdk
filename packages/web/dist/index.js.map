{"version":3,"sources":["../src/index.ts"],"sourcesContent":["// packages/web/src/index.ts\n\nimport type { PqKem, PqKemAlg, PqKemPublicKey } from \"./pqkem\";\n\nexport * from \"./pqkem\";\n\nexport interface QuantumAuthWebConfig {\n    qaClientBaseUrl: string;\n    backendBaseUrl: string;\n    pqKemAlg: PqKemAlg;\n    qaKemPublicKeyB64: string;\n    pqKem: PqKem;\n    appId?: string;\n}\n\nexport interface ProtectedCallOptions<TBody = unknown> {\n    method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n    path: string;\n    body?: TBody;\n    // userId / deviceId removed â€“ SDK will get them from the client\n}\n\n\nexport interface ProtectedCallResult<T = unknown> {\n    ok: boolean;\n    status: number;\n    headers: Headers;\n    data: T | null;\n    raw: Response;\n}\n\ninterface ChallengeResponse {\n    qaProof: Record<string, string>;\n}\n\nexport interface EncryptedPayload {\n    pq_kem_alg: PqKemAlg;\n    aead_alg: \"AES-GCM-256\";\n    kem_ciphertext_b64: string;\n    aead_iv_b64: string;\n    aead_ciphertext_b64: string;\n}\n\ninterface InternalEncryptOpts {\n    payload: unknown;\n}\n\nexport class QuantumAuthWebClient {\n    private readonly qaClientBaseUrl: string;\n    private readonly backendBaseUrl: string;\n\n    private readonly pqKem: PqKem;\n    private readonly pqKemAlg: PqKemAlg;\n    private readonly qaKemPublicKeyB64: string;\n\n    private kemPubKeyPromise: Promise<PqKemPublicKey> | null = null;\n\n    constructor(cfg: QuantumAuthWebConfig) {\n        this.qaClientBaseUrl = cfg.qaClientBaseUrl.replace(/\\/+$/, \"\");\n        this.backendBaseUrl = cfg.backendBaseUrl.replace(/\\/+$/, \"\");\n\n        this.pqKem = cfg.pqKem;\n        this.pqKemAlg = cfg.pqKemAlg;\n        this.qaKemPublicKeyB64 = cfg.qaKemPublicKeyB64;\n    }\n\n    // NEW: plain signed request (no encryption)\n    async request<TResp = unknown, TBody = unknown>(\n        opts: ProtectedCallOptions<TBody>\n    ): Promise<ProtectedCallResult<TResp>> {\n        const challenge = await this.requestChallenge({\n            method: opts.method,\n            path: opts.path,\n            backendHost: this.extractHost(this.backendBaseUrl),\n        });\n        const url = this.backendBaseUrl + opts.path;\n\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n        });\n\n        // merge QA signature headers from qa-client\n        for (const [k, v] of Object.entries(challenge.qaProof)) {\n            headers.set(k, v);\n        }\n\n        const resp = await fetch(url, {\n            method: opts.method,\n            headers,\n            body:\n                opts.method === \"GET\"\n                    ? undefined\n                    : JSON.stringify(opts.body ?? {}),\n            credentials: \"include\",\n        });\n\n        let data: TResp | null = null;\n        try {\n            const text = await resp.text();\n            data = text ? (JSON.parse(text) as TResp) : null;\n        } catch {\n            data = null;\n        }\n\n        return {\n            ok: resp.ok,\n            status: resp.status,\n            headers: resp.headers,\n            data,\n            raw: resp,\n        };\n    }\n\n    async callProtected<TResp = unknown, TBody = unknown>(\n        opts: ProtectedCallOptions<TBody>\n    ): Promise<ProtectedCallResult<TResp>> {\n        const challenge = await this.requestChallenge({\n            method: opts.method,\n            path: opts.path,\n            backendHost: this.extractHost(this.backendBaseUrl),\n        });\n\n        const encrypted = await this.encryptPayload({\n            payload: opts.body ?? {},\n        });\n\n        const url = this.backendBaseUrl + opts.path;\n\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n        });\n\n        console.log(\"headers\");\n\n\n        for (const [k, v] of Object.entries(challenge.qaProof)) {\n            headers.set(k, v);\n        }\n\n        const resp = await fetch(url, {\n            method: opts.method,\n            headers,\n            body:\n                opts.method === \"GET\"\n                    ? undefined\n                    : JSON.stringify(encrypted),\n            credentials: \"include\",\n        });\n\n        let data: TResp | null = null;\n        try {\n            const text = await resp.text();\n            data = text ? (JSON.parse(text) as TResp) : null;\n        } catch {\n            data = null;\n        }\n\n        return {\n            ok: resp.ok,\n            status: resp.status,\n            headers: resp.headers,\n            data,\n            raw: resp,\n        };\n    }\n\n    private async requestChallenge(params: {\n        method: string;\n        path: string;\n        backendHost: string;\n    }): Promise<ChallengeResponse> {\n        const url = `${this.qaClientBaseUrl}/api/qa/authenticate`;\n        const resp = await fetch(url, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                method: params.method,\n                path: params.path,\n                backend_host: params.backendHost,\n            }),\n            credentials: \"include\",\n        });\n\n        if (!resp.ok) {\n            const text = await resp.text();\n            throw new Error(`qa challenge failed: ${resp.status} ${text}`);\n        }\n\n        const json = await resp.json();\n\n        return {\n            qaProof: json.headers ?? {},\n\n        };\n    }\n\n    private async encryptPayload(opts: InternalEncryptOpts): Promise<EncryptedPayload> {\n        const kemPubKey = await this.getKemPublicKey();\n        const { sharedSecret, ciphertext } = await this.pqKem.encapsulate(kemPubKey);\n\n        const aeadKey = await this.deriveAeadKey(sharedSecret);\n\n        const plaintextObj = {\n            payload: opts.payload,\n        };\n\n        const plaintext = new TextEncoder().encode(JSON.stringify(plaintextObj));\n\n        const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV\n        const aeadCiphertext = await crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv },\n            aeadKey,\n            plaintext\n        );\n\n        return {\n            pq_kem_alg: this.pqKemAlg,\n            aead_alg: \"AES-GCM-256\",\n            kem_ciphertext_b64: this.bytesToBase64(ciphertext),\n            aead_iv_b64: this.bytesToBase64(iv),\n            aead_ciphertext_b64: this.bytesToBase64(\n                new Uint8Array(aeadCiphertext)\n            ),\n        };\n    }\n\n    private async getKemPublicKey(): Promise<PqKemPublicKey> {\n        if (!this.kemPubKeyPromise) {\n            this.kemPubKeyPromise = (async () => {\n                const raw = this.base64ToBytes(this.qaKemPublicKeyB64);\n                return this.pqKem.importPublicKey(raw, this.pqKemAlg);\n            })();\n        }\n        return this.kemPubKeyPromise;\n    }\n\n    private async deriveAeadKey(sharedSecret: Uint8Array): Promise<CryptoKey> {\n        const ikm = sharedSecret; // Uint8Array\n\n        const salt = new Uint8Array(32); // all zeros; you can change later\n        const info = new TextEncoder().encode(\"quantum-auth-pq-aead\");\n\n        // TS hack: Uint8Array IS an ArrayBufferView, which is a BufferSource.\n        // But the typings get confused because of ArrayBufferLike generics.\n        const hkdfKey = await crypto.subtle.importKey(\n            \"raw\",\n            ikm as unknown as BufferSource,\n            { name: \"HKDF\", hash: \"SHA-256\" },\n            false,\n            [\"deriveKey\"]\n        );\n\n        return crypto.subtle.deriveKey(\n            {\n                name: \"HKDF\",\n                hash: \"SHA-256\",\n                salt,\n                info,\n            },\n            hkdfKey,\n            { name: \"AES-GCM\", length: 256 },\n            false,\n            [\"encrypt\"]\n        );\n    }\n\n    private base64ToBytes(b64: string): Uint8Array {\n        const atobFn =\n            typeof atob === \"function\"\n                ? atob\n                : (b64Str: string) =>\n                    Buffer.from(b64Str, \"base64\").toString(\"binary\");\n\n        const bin = atobFn(b64);\n        const out = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);\n        return out;\n    }\n\n    private bytesToBase64(bytes: Uint8Array): string {\n        const btoaFn =\n            typeof btoa === \"function\"\n                ? btoa\n                : (binStr: string) =>\n                    Buffer.from(binStr, \"binary\").toString(\"base64\");\n\n        let binary = \"\";\n        for (let i = 0; i < bytes.length; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoaFn(binary);\n    }\n\n    private extractHost(url: string): string {\n        try {\n            const u = new URL(url);\n            return u.host;\n        } catch {\n            return url.replace(/^https?:\\/\\//, \"\").split(\"/\")[0];\n        }\n    }\n}\n"],"mappings":"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","names":[]}